[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 cppSim authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/getting_started_2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started","text":"cppSim package developed order possibility spatial interaction models scale regular spec machine. existing packages proposing similar functionality tend prioritize different functionalities, end suited small models, say dozen origins destinations. want analyse whole city, region, even country potentially hundreds thousands ODs ? cppSim steps . vignette present typical set one might SIMs. keep simple, focus modelling part. means cover steps getting data, building network, routing another, longer article. use data sets come package demonstrate power cppSim.","code":""},{"path":"/articles/getting_started_2.html","id":"set-up","dir":"Articles","previous_headings":"","what":"Set up","title":"Getting started","text":"Let’s install import library data sets. two data sets provided consist flow matrix flows_test cycling walking flows combined every MSOA Greater London. data obtained 2011 UK census open data portal. second matrix distance matrix centroids every MSOAs Greater London. computed using great cppRouting package OpenStreetMap networks adapted suitable cycling walking. networks can downloaded good format python package OSMnx, recently published, yet development cppRnet package R Let’s look size :","code":"# remotes::install_github('ischlo/cppSim')  library(cppSim) #> ℹ OpenMP detected, parallel computations will be performed.  data(\"distance_test\") data(\"flows_test\") data(\"london_msoa\") dim(distance_test) #> [1] 983 983 dim(flows_test) #> [1] 983 983 #> Warning in xy.coords(x, y, xlabel, ylabel, log): 1 x value <= 0 omitted from #> logarithmic plot"},{"path":[]},{"path":"/articles/getting_started_2.html","id":"model","dir":"Articles","previous_headings":"","what":"Model","title":"Getting started","text":"coefficient distance decay (cost) function known, one can simply run: Let’s look correlation model output data:  correlation already high, can better, , need calibrate model. done simulation function, find optimal cost function gives best fit.","code":"beta <- .1  res_model <- cppSim::run_model(flows = flows_test                          ,distance = distance_test                          ,beta = beta)  str(res_model) #> List of 1 #>  $ values: num [1:983, 1:983] 283.6 5.6 14.3 10.8 12.7 ...  dim(res_model$values) #> [1] 983 983 cor(c(res_model$values)     ,c(flows_test)) #> [1] 0.5903494"},{"path":"/articles/getting_started_2.html","id":"simulation","dir":"Articles","previous_headings":"Model","what":"Simulation","title":"Getting started","text":"want run full simulation calibrate model determine optimal distance decay coefficient, following: output list two elements, first output model run best fits observed data. Second, optimal distance decay exponent produces result. value relevant modelling. Let’s see model results:  Let’s see model output correlates observed data:","code":"res_sim <- cppSim::simulation(flows_matrix = flows_test                           ,dist_matrix = distance_test )  str(res_sim) #> List of 2 #>  $ best_fit_values: num [1:983, 1:983] 1.43e+03 2.87e-03 9.48e-03 8.72e-04 8.05e-03 ... #>  $ best_fit_beta  : num 0.962  res_sim$best_fit_beta #> [1] 0.9615716 plot(res_sim$best_fit_values      ,flows_test      # ,log = 'xy'      ,main = 'Model vs Data') cor(x=c(res_sim$best_fit_values)     ,y=c(flows_test)) #> [1] 0.9287456"},{"path":"/articles/gravity_model.html","id":"what-model-to-use","dir":"Articles","previous_headings":"","what":"What model to use ?","title":"Gravity model","text":"general version doubly constrained gravity model looks following way: Tij=AiBjOiDjf(cij) T_{ij} = A_iB_jO_iD_jf(c_{ij})  OiO_i working population origin, DjD_j available workplaces destination location: Oi=∑jTij O_i = \\sum_j T_{ij} Dj=∑iTij D_j = \\sum_i T_{ij} terms AiA_i,BjB_j factors location. derivation factors based relation: Ai=[∑jBjDjf(cij)]−1A_i = [\\sum_j B_jD_jf(c_{ij})]^{-1} Bj=[∑iAiOif(cij)]−1B_j = [\\sum_i A_iO_if(c_{ij})]^{-1} derivation made recursive chain initial values 1. Let’s refer parameters vectors →\\vec{},B→\\vec{B},O→\\vec{O},D→\\vec{D}, cost function flow matrices F T Fij=f(cij)F_{ij}=f(c_{ij}) TijT_{ij} flow j. Next, need run recursive procedure values stabilise. introduce threshold stop running recursion δ\\delta. corresponds rate change parameter respect previous iteration.","code":"# creating the O, D vectors.  O <- apply(flows_matrix, sum, MARGIN = 2) |> c()  D <- apply(flows_matrix, sum, MARGIN = 1) |> c() F_c <- cost_function(msoa_graph_dist,1,type = \"exp\") beta_calib <- foreach::foreach(i = 28:33                                ,.combine = rbind) %do% {                                  beta <- 0.1*(i - 1)                                  print(paste0(\"RUNNING MODEL FOR beta = \",beta))                                  run <- run_model(flows = flows_matrix                                                   ,distance = msoa_graph_dist                                                   ,beta = beta                                                   ,type = \"exp\"                                  )                                                                cbind(beta, run$r2,run$rmse)                                } ## [1] \"RUNNING MODEL FOR beta = 2.7\" ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.523562724685593\" ## [1] \"r2 = 0.569416661266395\" ## [1] \"RMSE = 761393\" ## [1] \"RUNNING MODEL FOR beta = 2.8\" ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.52139497161395\" ## [1] \"r2 = 0.564200958950744\" ## [1] \"RMSE = 782866\" ## [1] \"RUNNING MODEL FOR beta = 2.9\" ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.519608318386737\" ## [1] \"r2 = 0.559996858096147\" ## [1] \"RMSE = 802874\" ## [1] \"RUNNING MODEL FOR beta = 3\" ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.517600476428077\" ## [1] \"r2 = 0.555519600639465\" ## [1] \"RMSE = 823828\" ## [1] \"RUNNING MODEL FOR beta = 3.1\" ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.515506983755352\" ## [1] \"r2 = 0.551611759795211\" ## [1] \"RMSE = 843738\" ## [1] \"RUNNING MODEL FOR beta = 3.2\" ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.513382277125238\" ## [1] \"r2 = 0.547105339696983\" ## [1] \"RMSE = 864943\" plot(beta_calib[,1]      ,beta_calib[,2]      ,xlab = \"beta value\"      ,ylab = \"quality of fit, r\"      ,main = \"influence of beta on the goodness of fit\"      ,pch = 19      ,cex = 0.5      ,type = \"b\") beta_best_fit <- beta_calib[which(beta_calib[,2] == max(beta_calib[,2])),1] x <- seq_len(100)/20 plot(x      ,exp(-beta_best_fit*x)      ,main = \"cost function\"      ,xlab = \"distance, km\"      ,ylab = \"decay factor\"      ,pch = 19      ,cex = 0.5      ,type = \"l\") run_best_fit <- run_model(flows = flows_matrix                  ,distance = msoa_graph_dist                  ,beta = beta_best_fit                  ,type = \"exp\"                  ) ## [1] \"cost function computed\" ## [1] \"calibration: over\" ## [1] \"model run: over\" ## [1] \"E_sor = 0.523562724685593\" ## [1] \"r2 = 0.569416661266395\" ## [1] \"RMSE = 761393\" plot(seq_along(run_best_fit$calib)      ,run_best_fit$calib      ,xlab = \"iteration\"      ,ylab = \"error\"      ,main = \"calibration of balancing factors\"      ,pch = 19      ,cex = 0.5      ,type = \"b\"       ) plot(flows_matrix      ,run_best_fit$values      ,ylab = \"flows model\"      ,xlab = \"flows\"      ,log = \"xy\"      ,pch = 19      ,cex = 0.5) lines(seq_len(max(run_best_fit$values))       ,seq_len(max(run_best_fit$values))       ,col = \"darkred\"       ,lwd = 2) ## MODEL USING THE GLM And POISSON DISTRIBUTION  flows_london <- rlist::list.load(\"flows_london.rds\")  sample_od <- sample(unique(flows_london$workplace),100)  flows_grav <- flows_london[(workplace %in% sample_od) & (residence %in% sample_od),]  flows_grav[,O := sum(bike),by = from_id]  flows_grav[,D := sum(bike), by = to_id]  #  model <- glm(bike ~ workplace+residence+distance -1              ,data = flows_grav              ,family = poisson(link = \"log\")              )  ((model$fitted.values - flows_grav$bike)) |> hist(breaks = 100) r2 <- r_2(flows_grav$bike,model$fitted.values) r2 ## [1] 0.8854178"},{"path":"/articles/gravity_model.html","id":"support-functions","dir":"Articles","previous_headings":"","what":"Support functions","title":"Gravity model","text":"","code":"print(\"cost function:\") ## [1] \"cost function:\" cost_function ## function(d, beta, type = \"exp\") { ##  ##   # d is the od distance matrix, taking the exponential ##   # means doing this operation for each individual element ##   #  with an exponent beta ##   # the type parameter allows to set it to either exp or pow. ##   #  pow means we use a power function as cost, rather than exponential ##  ##   if (type == \"exp\") { ##     exp(-beta*d) ##   } else if (type == \"pow\") { ##     d^(-beta) ##   } else { ##     print(\"provide a type of functino to compute\") ##   } ## } ## <bytecode: 0x55d252395508> print(\"calibration function:\") ## [1] \"calibration function:\" calibration ## function(cost_fun,O,D,delta = 0.05) { ##   B <- rep_len(1,nrow(cost_fun)) ##   eps <- abs(sum(B)) ##   e <- NULL ##   i <- 0 ##   while((eps > delta) & (i<50)) { ##     A_new <- 1/(apply(cost_fun,function (x) sum(B*D*x),MARGIN = 1)) ##     B_new <- 1/(apply(cost_fun,function (x) sum(A_new*O*x),MARGIN = 2)) ##     eps <- abs(sum(B_new-B)) ##     e <- append(e,eps) ##     A <- A_new ##     B <- B_new ##     i <- i+1 ##   } ##   list( ##     \"A\"= A ##     ,\"B\" = B ##     ,\"e\" = e ##     ) ## } ## <bytecode: 0x55d24eca50d0> print(\"model run\") ## [1] \"model run\" run_model ## function(flows ##                       ,distance ##                       ,beta = 0.25 ##                       ,type = \"exp\" ##                       #,cores = 3 ##                       ) { ##  ##   F_c <- cost_function(d = {{distance}},beta = {{beta}},type = type) ##   print(\"cost function computed\") ##   O <- apply(flows,sum, MARGIN = 1) |> as.integer() ##   D <- apply(flows,sum, MARGIN = 2) |> as.integer() ##   A_B <- calibration(cost_fun = F_c ##                      ,O=O ##                      ,D=D ##                      ,delta = .001) ##   print(\"calibration: over\") ##   A <- A_B$A ##   B <- A_B$B ##  ##   flows_model <- foreach(j = c(1:nrow(F_c)) ##                          ,.combine = rbind) %do% { ##                            round(A[j]*B*O[j]*D*F_c[j,]) ##                          } ##  ##   print(\"model run: over\") ##   e_sor <- e_sorensen(flows,flows_model) |> as.numeric() ##   print(paste0(\"E_sor = \",e_sor)) ##   r2 <- r_2(flows_model,flows) |> as.numeric() ##   print(paste0(\"r2 = \",r2)) ##   RMSE <- rmse(flows_model,flows) |> as.numeric() ##   print(paste0(\"RMSE = \",RMSE)) ##  ##   list(\"values\" = flows_model ##        ,\"r2\" = r2 ##        ,\"rmse\" = RMSE ##        ,\"calib\" = A_B$e ##        ,\"e_sor\" = e_sor ##        ) ##  ## } ## <bytecode: 0x55d2526b9378>"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ivann Schlosser. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schlosser (2024). cppSim: Fast memory efficient spatial interaction models. R package version 0.2, https://github.com/ischlo/cppSim, https://ischlo.github.io/cppSim/.","code":"@Manual{,   title = {cppSim: Fast and memory efficient spatial interaction models},   author = {Ivann Schlosser},   year = {2024},   note = {R package version 0.2, https://github.com/ischlo/cppSim},   url = {https://ischlo.github.io/cppSim/}, }"},{"path":"/index.html","id":"cppsim","dir":"","previous_headings":"","what":"Fast and memory efficient spatial interaction models","title":"Fast and memory efficient spatial interaction models","text":"aims providing set fast, memory efficient functions perform spatial interaction modelling, also called gravity modelling. Currently, doubly singly constrained models implemented canonical set constraints. Future versions aim implement origin destination constraints well. developed context studying commuter flows active travel (cycling & walking ) Great Britain part project CASA, UCL.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fast and memory efficient spatial interaction models","text":"yet CRAN, please install development version cppSim :","code":"# install.packages(C(\"devtools\",\"pak\"))  devtools::install_github(\"ischlo/cppSim\") # pak::pak(\"ischlo/cppSim\")"},{"path":"/index.html","id":"built-in-data-sets","dir":"","previous_headings":"","what":"Built in data sets","title":"Fast and memory efficient spatial interaction models","text":"package comes sample data sets allow test functions right away well see type input recommended. flows_test : using official census data England 2011, ’s 983x983 matrix representing flows cyclists pedestrians MSOA London. distance_test : distances centroids MSOAs. Computed London road network OpenStreetMap using cppRouting package.","code":""},{"path":"/index.html","id":"spatial-interaction-models","dir":"","previous_headings":"","what":"Spatial interaction models","title":"Fast and memory efficient spatial interaction models","text":"Refer vignette find theory SIMs naive implementation R.","code":""},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Fast and memory efficient spatial interaction models","text":"Using built-data sets flows_test distance_test, can run test following example basic example shows solve common problem:","code":"library(cppSim) ## basic example code  data(\"flows_test\") data(\"distance_test\")   model_test <- run_model(   flows = flows_test,   distance = distance_test )"},{"path":"/index.html","id":"source","dir":"","previous_headings":"","what":"Source","title":"Fast and memory efficient spatial interaction models","text":"example can done package, please refer publication active travel spatial interaction models London originally developed. Schlosser, ., Maureira, V.M., Milton, R., Arcaute, E., Batty, M., 2023. Active-travel modelling: methodological approach networks walking cycling commuting analysis. accompanying code analysis provided ischlo/quant_cycle_walk repository.","code":""},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Fast and memory efficient spatial interaction models","text":"package dependencies might need manual installation, although important external ones provided source code.","code":""},{"path":"/index.html","id":"external","dir":"","previous_headings":"Dependencies","what":"External","title":"Fast and memory efficient spatial interaction models","text":"package uses armadillo library, imported linked automatically package installed.","code":""},{"path":"/index.html","id":"other","dir":"","previous_headings":"Dependencies","what":"Other","title":"Fast and memory efficient spatial interaction models","text":"R side, uses Rcpp (Eddelbuettel François 2011) RcppArmadillo (Eddelbuettel Sanderson 2014).","code":""},{"path":"/index.html","id":"performance","dir":"","previous_headings":"","what":"Performance","title":"Fast and memory efficient spatial interaction models","text":"Compared equivalent functions implemented pure R, runs x10 faster ∼1000×1000\\sim 1000\\times 1000 OD matrix, speed increasignly significant matrices get bigger.","code":"#> [1] \"\""},{"path":[]},{"path":"/reference/calibration_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrating the balancing factors — calibration_cpp","title":"Calibrating the balancing factors — calibration_cpp","text":"Function calibrate B coefficients gravity model ","code":""},{"path":"/reference/cpp_found_openmp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to check availability of OPENMP to run in parallel. If openmp is found, this function returns TRUE — cpp_found_openmp","title":"Function to check availability of OPENMP to run in parallel. If openmp is found, this function returns TRUE — cpp_found_openmp","text":"Function check availability OPENMP run parallel. openmp found, function returns TRUE","code":""},{"path":"/reference/cpp_found_openmp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to check availability of OPENMP to run in parallel. If openmp is found, this function returns TRUE — cpp_found_openmp","text":"","code":"cpp_found_openmp()"},{"path":"/reference/distance_test.html","id":null,"dir":"Reference","previous_headings":"","what":"distance_test — distance_test","title":"distance_test — distance_test","text":"distance_test","code":""},{"path":"/reference/distance_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distance_test — distance_test","text":"","code":"distance_test"},{"path":[]},{"path":"/reference/distance_test.html","id":"distance-test","dir":"Reference","previous_headings":"","what":"distance_test","title":"distance_test — distance_test","text":"983x983 matrix distances MSOAs London. Computed using London road network OpenStreetMap cppRouting package.","code":""},{"path":"/reference/distance_test.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"distance_test — distance_test","text":"Ivann Schlosser, 2022","code":""},{"path":"/reference/flows_test.html","id":null,"dir":"Reference","previous_headings":"","what":"flows_test — flows_test","title":"flows_test — flows_test","text":"flows_test","code":""},{"path":"/reference/flows_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"flows_test — flows_test","text":"","code":"flows_test"},{"path":[]},{"path":"/reference/flows_test.html","id":"flows-test","dir":"Reference","previous_headings":"","what":"flows_test","title":"flows_test — flows_test","text":"matrix size 983x983 containing flows users using walking cycling main method commute.","code":""},{"path":"/reference/flows_test.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"flows_test — flows_test","text":"UK Census, 2011","code":""},{"path":"/reference/london_msoa.html","id":null,"dir":"Reference","previous_headings":"","what":"london_msoa — london_msoa","title":"london_msoa — london_msoa","text":"london_msoa","code":""},{"path":"/reference/london_msoa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"london_msoa — london_msoa","text":"","code":"london_msoa"},{"path":[]},{"path":"/reference/london_msoa.html","id":"london-msoa","dir":"Reference","previous_headings":"","what":"london_msoa","title":"london_msoa — london_msoa","text":"data.table London MSOA, centroids geometries","code":""},{"path":"/reference/london_msoa.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"london_msoa — london_msoa","text":"ONS, Office National Statistics, 2011","code":""},{"path":"/reference/run_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Running doubly constrained model — run_model","title":"Running doubly constrained model — run_model","text":"function C++ implementation run_model, run doubly constrained model","code":""},{"path":"/reference/run_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Running doubly constrained model — run_model","text":"","code":"run_model(flows, distance, beta = 0.25)"},{"path":"/reference/run_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Running doubly constrained model — run_model","text":"flows integer matrix Origin-Destination flows. distance distance matrix origins destinations, provide distance km. beta Exponent use calculating cost function.","code":""},{"path":"/reference/run_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Running doubly constrained model — run_model","text":"list containing integer matrix predicted values.","code":""},{"path":"/reference/run_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Running doubly constrained model — run_model","text":"","code":"data(flows_test) data(distance_test)  model_test <- run_model(flows_test,distance_test)"},{"path":"/reference/run_model_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Run model — run_model_cpp","title":"Run model — run_model_cpp","text":"function C++ implementation run_model, run model","code":""},{"path":"/reference/run_model_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run model — run_model_cpp","text":"flows integer matrix Origin-Destination flows. distance distance matrix origins destinations. beta Exponent use calculating cost function.","code":""},{"path":"/reference/run_model_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Running a singly constrained model — run_model_single","title":"Running a singly constrained model — run_model_single","text":"function C++ implementation run_model, run singly constrained model must match dimensions, running production constrained model, (dim(distance) == length(flows)) must TRUE values weight provided, vector ones used","code":""},{"path":"/reference/run_model_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Running a singly constrained model — run_model_single","text":"","code":"run_model_single(flows, distance, weight = NULL, beta = 0.25)"},{"path":"/reference/run_model_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Running a singly constrained model — run_model_single","text":"flows vector either origin (production constrained) destination (attraction constrained) flows. distance distance matrix origins destinations, provide distance km. weight vector weights unconstrained part model. beta Exponent use calculating cost function, default .25.","code":""},{"path":"/reference/run_model_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Running a singly constrained model — run_model_single","text":"list containing matrix predicted values.","code":""},{"path":"/reference/run_model_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Running a singly constrained model — run_model_single","text":"","code":"data(flows_test) data(distance_test)  flows_test <- apply(flows_test,MARGIN = 1,FUN = sum)  model_test <- run_model_single(flows_test,distance_test)"},{"path":"/reference/simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Running a whole simulation of a doubly constrained gravity model — simulation","title":"Running a whole simulation of a doubly constrained gravity model — simulation","text":"script takes flows data, distance matrix, reference beta parameter finds optimal beta value model, runs , returns result beta best fit. currently exp value accepted cost_fun parameter.","code":""},{"path":"/reference/simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Running a whole simulation of a doubly constrained gravity model — simulation","text":"","code":"simulation(flows_matrix, dist_matrix, beta_offset = 0.25)"},{"path":"/reference/simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Running a whole simulation of a doubly constrained gravity model — simulation","text":"flows_matrix integer matrix flows dist_matrix distance matrix containing numeric values kilometers beta_offset offset 0 start looking best fit value.","code":""},{"path":"/reference/simulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Running a whole simulation of a doubly constrained gravity model — simulation","text":"creates folder based run_name parameter images files written. file run_name_best_fit.rds contain matrices values model , quality fit values beta values.","code":""},{"path":"/reference/simulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Running a whole simulation of a doubly constrained gravity model — simulation","text":"","code":"data(flows_test) data(distance_test)  model <- simulation(flows_test,distance_test)"},{"path":"/news/index.html","id":"cppsim-02","dir":"Changelog","previous_headings":"","what":"cppSim 0.2","title":"cppSim 0.2","text":"main update version integration armadillo library package facilitate dependencies user side. vignette now introduces minimal workflow using cppSim, another one goes basics spatial interaction models simple R implementation. soon published one cover case study network routing steps scratch.","code":""},{"path":"/news/index.html","id":"cppsim-01","dir":"Changelog","previous_headings":"","what":"cppSim 0.1","title":"cppSim 0.1","text":"Added NEWS.md file track changes package.","code":""}]
